采用二分的方法，复杂度O(logn)

取模的话可以直接加在函数里
```
int fast(int a,int n){//计算a的n次方
    if(n==0)return 1;
    if(n%2)return a*fast(a,n-1);
    int tmp=fast(a,n/2);
    return tmp*tmp;
}
```
也可以采用循环写法，避免爆栈

```
int fast(int a,int n){
    int ret = 1;
    while(n>0){
        if(n%2)ret*=a;
        n>>=1;
        a*=a;
    }
    return ret;
}
```

如果计算 (a^n)%c ，其中a，n，c数据最大为 2^63-1 的话，上述方法虽然速度很快，但其中的乘法的中间值会超过 2^64-1（计算机最长数据），那如何解决乘法溢出问题呢？

方法就是模拟计算机的乘法过程：
数字采用二进制表示后，模拟手算过程，比如
a = 1011，b=101

```
    1011
  *  101
  ------
    1011
   0000
  1011
```
当b的某一位上是1时就将a照搬下来，是0时就全为0
当a照搬下来时要对应的在后面补0
最后相加即得乘法结果

```
int mult(int a,int b){
    int sum=0;
    while(b){
        if(b&1)sum+=a;
        a<<=1;
        b>>=1;
    }
    return sum;
}
```
然后将取模操作加入其中即可
