**素数筛法**能很快的求出N以内的所有素数
原理：若一个数不是素数，则必存在一个小于它的素数为它的因子，所以在获得一个素数时，将它的所有倍数都标记为非素数，这样当遍历到一个数时，如果它没有被任何小于它的素数标记为非素数，那么它就一定是素数

#方法一：
```
#define N 1000000
int a[N];   //素数标记为0，非素数标记为1
vector<int>p;
void Init(){
    memset(a,0,sizeof(a));
    for(int i=2;i<N;i++){   //N以内所有素数
        if(a[i]==0){    //i是素数
            p.push_back(i);
            for(int j=i+i;j<N;j+=i) //i的倍数标记为非素数
                a[j]=1;
        }
    }
}

```
上面那种方法仔细分析发现很多合数被反复筛选过，比如素数2会把6筛选一次，素数3又会把6筛选一次，这样重复筛选，影响效率
***
#方法二：
```
#define N 1000000
int a[N];
vector<int>p;
void Init(){
    memset(a,0,sizeof(a));
    for(int i=2;i<N;i++){
        if(a[i]==0)p.push_back(i);//未被标记，是素数
        for(int j=0;j<p.size()&&i*p[j]<N;j++){  //用当前这p.size()-1个素数（从小到大）去筛选合数
            a[i*p[j]]=1;    //合数i*p[j]被筛选
            if(i%p[j]==0)break;//如果i是素数，那么会用上前p.size()-1个所有的素数，（当然先到i*p[j]>=N的话会提前结束）
                               //如果i是合数，那么会用上前面部分素数，遇到i的素因子就会跳出，
                               //这样每个合数就会只被标记一次
        }
    }
}
```
这种方法由于每个合数只被标记一次，所以复杂度相当于线性的
