#[中国剩余定理百度百科上讲的很详细](http://baike.baidu.com/link?url=Em0IthgOqzmQ2mZZX5qVDCJzeXSZ8t9PE3IviQmvn04mf2B5BbzI7nW6FkQppHfMtDa37yYFVG-2Kzbr-xmUxxKIkluRvVLF9ZXvqm-JkuZgxQVZuIxnDSI4xtkUAdLFLLhs4WNr53D1J7ctfzUM0CpDXzkykcU0U9mbkEEgaH_mZm14dVOlQ_7tQKBVQ_2gvg8mAQC2Leug5Nl_y6SrDK)  
![](http://g.hiphotos.baidu.com/baike/s%3D189/sign=a6b9360a4234970a43731427accad1c0/80cb39dbb6fd5266de7cc231a818972bd40736bb.jpg)  
给出ai和mi求x，mi两两互质。  
设<img src="http://latex.codecogs.com/svg.latex?M=\prod_{i=1}^{n}m_i">,
<img src="http://latex.codecogs.com/svg.latex?M_i=\frac{M}{m_i}">  
则x的通解为<img src="http://latex.codecogs.com/svg.latex?kM+\sum_{i=1}^{n}a_iM_i*inv(M_i)">,inv(Mi)表示Mi在模mi下的逆元。
```
const int maxn=1e5;

int pow(int a,int n,int p){
    if(n==0)return 1;
    if(n&1)return a*pow(a,n-1,p)%p;
    int t=pow(a,n/2,p);
    return t*t%p;
}
int inv(int a,int p){return pow(a,p-2,p);}

int n;
int m[maxn+5];
int a[maxn+5];
int crt(){
    int M=1;for(int i=1;i<=n;i++)M*=m[i];
    int x=0;for(int i=1;i<=n;i++)x+=a[i]*(M/m[i])*inv(M/m[i],m[i]);
    return x;
}
```
#中国剩余定理的推广(mi不要求两两互质)  
考虑< a1,m1 >和< ai,mi >:  
```
x%m1=a1
x%mi=ai
x=a1+k1*m1=ai-ki*mi
k1*m1+ki*mi=ai-a1
只有(ai-a1)|gcd(m1,mi)才有整数解
用扩展欧几里得求得k1的通解为k1+k*mi/gcd(m1,mi)
所以x=a1+k1*m1+k*lcm(m1,mi)
因此<ai,mi>便合并到<a1,m1>中变成了<a1+k1*m1,lcm(m1,mi)>
然后把剩余的都合并到<a1,m1>最终的a1便是要求的x
```
```
const int maxn=1e5;

void gcd(int a,int b,int &d,int &x,int &y){
    if(b==0)d=a,x=1,y=0;
    else gcd(b,a%b,d,y,x),y-=x*(a/b);
}

int n;
int m[maxn+5];
int a[maxn+5];

int crt(){
    int k1,ki,d;
    for(int i=2;i<=n;i++){
        gcd(m[1],m[i],d,k1,ki);
        if((a[i]-a[1])%d)return -1;//无解
        k1*=(a[i]-a[1])/d;
        int lcm=m[1]/d*m[i];//防止溢出
        int k=ceil(-((double)a[1]/lcm+(double)k1/lcm*m[1]));//防止溢出
        a[1]+=k1*m[1]+k*lcm;//使a[1]非负且最小
        m[1]=lcm;
    }
    return a[1];
}
```
##[poj2891Strange Way to Express Integers直接套板即可，溢出的地方已经在模板中注意了](http://poj.org/problem?id=2891)
