[网上对旋转卡壳的解释和写法很清楚了，推荐看这个博客](http://www.cnblogs.com/xdruid/archive/2012/07/01/2572303.html)  
其中有用的信息如下：  
用两条平行直线卡住凸包，其中有条边和直线重合  
![](http://pic002.cnblogs.com/images/2012/408767/2012070122055388.png)  
可以看出**一个对踵点和对应边之间的距离比其他点要大，也就是一个对踵点和对应边所形成的三角形面积是最大的：**  
![](http://pic002.cnblogs.com/images/2012/408767/2012070122172275.png)  
枚举凸包上的点i，再枚举点j，如果三角形(i,i+1,j+1)比三角形(i,i+1,j)面积要大，那么j++，
否则点对(i,j)就是对踵点，枚举完所有的对踵点取距离最大的对踵点便是凸包直径（
注意j和j+1都要对n取模。）  
这样枚举复杂度是O(n^2)，还好有个性质：**凸包上的点依次与对应边产生的距离成单峰函数**，
所以在逆时针枚举边的时候**最远点的变化也是逆时针的**，这样就可以不用从头计算最远点，而可以紧接着**上一次的最远点**继续计算，复杂度O(n)  

```
template<class T>
double rotCal(T first,T last) {//参数是凸包点集的起点和终点
    vector<point>v(first,last);
    double ans=0;
    for(int i=0,j=1; i+1<v.size(); i++) {//j是循环的，记得对size取模
        while((v[i+1]-v[i]).cross(v[(j+1)%v.size()]-v[i])>(v[i+1]-v[i]).cross(v[j%v.size()]-v[i]))j++;//三角形(i,i+1,j+1)和(i,i+1,j)面积比较
        ans=max(ans,max(v[i].dis(v[j%v.size()]),v[i+1].dis(v[(j+1)%v.size()])));
    }
    return ans;//返回凸包直径
}
```

[uva4728凸包直径](https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2729)  
题意：给出100 000*4个点，求最远两点的距离  
分析：直接枚举复杂度为O(n^2)会超时，所以只能用凸包直径求  
主程序如下：
```
const double eps=1e-8;
const int maxn=100000;

point p[maxn*4+5];

int main() {
    int T;
    scanf("%d",&T);
    for(int t=1; t<=T; t++) {
        int n;
        scanf("%d",&n);
        for(int i=1; i<=n*4; i+=4) {
            p[i].read();
            double w;
            scanf("%lf",&w);
            p[i+1]=p[i]+vct {w,0};
            p[i+2]=p[i]+vct {0,w};
            p[i+3]=p[i]+vct {w,w};
        }
        vector<point>v;
        convexHull(p+1,p+1+n*4,v);
        double ans=rotCal(v.begin(),v.end());
        printf("%.f\n",ans*ans);
    }
}
```
