[网上对旋转卡壳的解释和写法很清楚了，推荐看这个博客](http://www.cnblogs.com/xdruid/archive/2012/07/01/2572303.html)  
其中有用的信息如下：  
用两条平行直线卡住凸包，其中有条边和直线重合  
![](http://pic002.cnblogs.com/images/2012/408767/2012070122055388.png)  
可以看出**一个对踵点和对应边之间的距离比其他点要大，也就是一个对踵点和对应边所形成的三角形面积是最大的：**  
![](http://pic002.cnblogs.com/images/2012/408767/2012070122172275.png)  
枚举凸包上的点i，再枚举点j，如果三角形(i,i+1,j+1)比三角形(i,i+1,j)面积要大，那么j++，
否则点对(i,j)就是对踵点，枚举完所有的对踵点取距离最大的对踵点便是凸包直径（
注意j和j+1都要对n取模。）  
这样枚举复杂度是O(n^2)，还好有个性质：**凸包上的点依次与对应边产生的距离成单峰函数**，
所以在逆时针枚举边的时候**最远点的变化也是逆时针的**，这样就可以不用从头计算最远点，而可以紧接着**上一次的最远点**继续计算，复杂度O(n)  

```
template<class T>
double rotCal(T first,T last) {//参数是凸包点集的起点和终点
    vector<point>v(first,last);
    double ans=0;
    for(int i=0,j=1; i+1<v.size(); i++) {//j是循环的，记得对size取模
        while((v[i+1]-v[i]).cross(v[(j+1)%v.size()]-v[i])>(v[i+1]-v[i]).cross(v[j%v.size()]-v[i]))j++;//三角形(i,i+1,j+1)和(i,i+1,j)面积比较
        ans=max(ans,max(v[i].dis(v[j%v.size()]),v[i+1].dis(v[(j+1)%v.size()])));
    }
    return ans;//返回凸包直径
}
```
