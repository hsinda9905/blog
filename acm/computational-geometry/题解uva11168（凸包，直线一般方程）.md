[给出平面上10000个点，找一条直线使所有点在直线同侧（也可以在直线上），且到直线的距离之和最小。](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2109)  
这条直线一定是凸包的一个边，怎么确定是哪条边呢？  
直线一般方程为：Ax+By+C=0，则点
<img src="http://chart.apis.google.com/chart?cht=tx&chl=(%20x_%7B0%7D%2C%20y_%7B0%7D)">
到直线的距离为：  
<img src="http://chart.apis.google.com/chart?cht=tx&chl=%5Cfrac%7B%7CA%20x_%7B0%7D%2BB%20y_%7B0%7D%2BC%7C%7D%7B%20%5Csqrt%7B%20A%5E%7B2%7D%2B%20B%5E%7B2%7D%7D%20%7D%20">  
由于所有点都在Ax+By+C=0同侧，所以
<img src="http://chart.apis.google.com/chart?cht=tx&chl=A%20x_%7B0%7D%2BB%20y_%7B0%7D%2BC">
的正负号相同，这样预处理所有点x坐标和y坐标之和，然后枚举凸包的边即可求出最小距离和。 

[凸包见模板](https://github.com/poluner/blog/blob/master/acm/computational-geometry/%E6%A8%A1%E6%9D%BF%E5%87%B8%E5%8C%85andrew%E7%AE%97%E6%B3%95.md)
主程序如下：  
```
const double eps=1e-5;
const double inf=1e9;
const int maxn=10000;

point p[maxn+5];

int main(){
    int T;
    scanf("%d",&T);
    for(int t=1;t<=T;t++){
        printf("Case #%d: ",t);
        int n;
        scanf("%d",&n);
        double sx=0,sy=0;
        for(int i=1;i<=n;i++){
            p[i].read();
            sx+=p[i].x;
            sy+=p[i].y;
        }

        if(n==1||n==2){
            puts("0.000");
            continue;
        }

        double ans=inf;

        vector<point>v;
        convexHull(p+1,p+1+n,v);

        v.push_back(v.front());//将第一个点加进去，因为第一个点和最后一个点也构成一个直线
        for(int i=1;i<v.size();i++){
            double A=v[i-1].y-v[i].y;
            double B=v[i].x-v[i-1].x;
            double C=v[i-1].x*v[i].y-v[i].x*v[i-1].y;

            double sd=fabs((A*sx+B*sy+C*n)/sqrt(A*A+B*B));
            ans=min(ans,sd);
        }
        printf("%.3f\n",ans/n);
    }
}
```
