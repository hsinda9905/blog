```
#include<bits/stdc++.h>
#define vct point
using namespace std;
const int maxn=1e3;

struct point{
    double x,y,z;
    vct operator-(vct b){return {x-b.x,y-b.y,z-b.z};}
    double dot(vct b){return x*b.x+y*b.y+z*b.z;}
    vct cross(vct b){return {y*b.z-z*b.y,z*b.x-x*b.z,x*b.y-y*b.x};}
};

struct tri{
    int v[3];
    vct normal(point *p)const{return (p[v[1]]-p[v[0]]).cross(p[v[2]]-p[v[0]]);}
    bool cansee(point *p,int i)const{return (p[i]-p[v[0]]).dot(normal(p))>0;}
};
bool vis[maxn+5][maxn+5];
vector<tri>ch(point *p,int n){//没有考虑4点共面，调用前应对输入点进行微小扰动
    memset(vis,false,sizeof vis);
    vector<tri>cur;
    cur.push_back(tri{0,1,2});
    cur.push_back(tri{2,1,0});
    for(int i=3;i<n;i++){
        vector<tri>nxt;
        //计算每条边左边的可见性
        for(int j=0;j<cur.size();j++){
            tri &t=cur[j];
            bool res=t.cansee(p,i);
            if(!res)nxt.push_back(t);
            for(int k=0;k<3;k++)vis[t.v[k]][t.v[(k+1)%3]]=res;
        }
        for(int j=0;j<cur.size();j++){
            for(int k=0;k<3;k++){
                int a=cur[j].v[k];
                int b=cur[j].v[(k+1)%3];
                if(vis[a][b]!=vis[b][a]&&vis[a][b])nxt.push_back(tri{a,b,i});
            }
        }
        cur=nxt;
    }
    return cur;
}
```
微小扰动：
```
double rand01(){return rand()/(double)RAND_MAX;}//0-1的随机数
double randeps(){return (rand01()-0.5)*eps;}//-eps/2到eps/2的随机数
```

##[hdu4266The Worm in the Apple](http://acm.hdu.edu.cn/showproblem.php?pid=4266)  
题意：求凸包，然后求给定点到凸包的表面所在平面的最小距离。  
下面给出除了模板之外的代码：  
```
const int maxn=1e3;

struct point{
    void read(){scanf("%lf%lf%lf",&x,&y,&z);}
    double dis(){return sqrt(dot(*this));}
    double area(point b,point c){return (b-*this).cross(c-*this).dis();}//三角形有向面积
};

double area6(point a,point b,point c,point d){return (d-a).dot((b-a).cross(c-a));}//ab,ac,ad的混和积，绝对值等于四面体abcd有向面积的6倍

struct tri{
    double dis(point *p,point q){//点q到三角形所在平面的距离
        double V=fabs(area6(q,p[v[0]],p[v[1]],p[v[2]]));
        double S=fabs(p[v[0]].area(p[v[1]],p[v[2]]));
        return V/S;//体积除底面积
    }
};

point p[maxn+5];

int main(){
    int n;
    while(~scanf("%d",&n)&&n){
        for(int i=0;i<n;i++)p[i].read();
        memset(vis,false,sizeof vis);
        vector<tri>c=ch(p,n);
        int q;scanf("%d",&q);
        point w;
        while(q--){
            w.read();
            double ans=1e9;
            for(int i=0;i<c.size();i++)ans=min(ans,c[i].dis(p,w));
            printf("%.4f\n",ans);
        }
    }
}
```
