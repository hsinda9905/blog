#在升序中找到第一个>=key的值，同lower_bound  
```
int lower_bound(int l,int r,int key) {
    if(a[r]<key)return r+1;

    while(l<r) {
        int m=(l+r)/2;
        if(a[m]<key)l=m+1;
        else r=m;    //a[r]>=key
    }
    return r;
}
```
#在升序中找到第一个>key的值，同upper_bound
```
int upper_bound(int l,int r,int key){
    if(a[r]<=key)return r+1;

    while(l<r){
        int m=(l+r)/2;
        if(a[m]<=key)l=m+1;
        else r=m;    //a[r]>key
    }
    return r;
}
```
#求最大化最小值或最小化最大值时，通过二分答案然后判断答案是否可行的方式求解  
##[poj2456最大距离最小](http://poj.org/problem?id=2456)  
题意：给出n个牛舍的坐标和c个牛，要求将牛放在牛舍并且使牛的距离尽量大，求最近牛的距离。  
分析：二分距离d，然后判断牛是否可以按照距离d放置。  
```
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=1e5;

int x[maxn+5];
int n,c;

bool check(int d){
    int cnt=0;
    int j=1;
    for(int i=2;i<=n&&j<c;i++){
        cnt+=x[i]-x[i-1];
        if(cnt>=d)j++,cnt=0;
    }
    return j==c;
}

int upper_bound(int l,int r){//找到最后一个可行的下一个位置
    while(l<r){
        int m=(l+r)/2;
        if(check(m))l=m+1;
        else r=m;
    }
    return r;
}

int main(){
    scanf("%d%d",&n,&c);
    for(int i=1;i<=n;i++)scanf("%d",&x[i]);

    sort(x+1,x+1+n);
    printf("%d\n",upper_bound(0,1e9)-1);
}
```
