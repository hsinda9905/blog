#在升序中找到第一个>=key的值，同lower_bound  
```
int lower_bound(int l,int r,int key) {
    if(a[r]<key)return r+1;

    while(l<r) {
        int m=(l+r)/2;
        if(a[m]<key)l=m+1;
        else r=m;    //a[r]>=key
    }
    return r;
}
```
#在升序中找到第一个>key的值，同upper_bound
```
int upper_bound(int l,int r,int key){
    if(a[r]<=key)return r+1;

    while(l<r){
        int m=(l+r)/2;
        if(a[m]<=key)l=m+1;
        else r=m;    //a[r]>key
    }
    return r;
}
```
